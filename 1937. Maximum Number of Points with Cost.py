"""
You are given an m x n integer matrix points (0-indexed).
Starting with 0 points, you want to maximize the number of points you can get from the matrix.

To gain points, you must pick one cell in each row.
Picking the cell at coordinates (r, c) will add points[r][c] to your score.

However, you will lose points if you pick a cell too far from the cell that you picked in the previous row.
For every two adjacent rows r and r + 1 (where 0 <= r < m - 1),
picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.

Return the maximum number of points you can achieve.

abs(x) is defined as:

    x for x >= 0.
    -x for x < 0.
------------------------
Вам дана матрица целых чисел размером m x n, названная points (индексация с нуля).
Начав с 0 очков, вы хотите максимизировать количество очков, которые можно набрать из матрицы.

Чтобы заработать очки, вы должны выбрать одну ячейку в каждой строке.
Выбор ячейки по координатам (r, c) добавит points[r][c] к вашему счету.

Однако вы потеряете очки, если выберете ячейку, слишком далеко от ячейки,
выбранной в предыдущей строке. За каждую пару соседних строк r и r + 1 (где 0 <= r < m - 1),
выбор ячеек по координатам (r, c1) и (r + 1, c2) уменьшит ваш счет на abs(c1 - c2).

Верните максимальное количество очков, которое вы можете получить.

abs(x) определяется как:

- x, если x >= 0.
- -x, если x < 0.
------------------------
MEDIUM
"""
from typing import List


class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        m, n = len(points), len(points[0])

        # dp будет хранить максимальные очки на каждой строке
        dp = [0] * n

        for r in range(m):
            # Левый проход для вычисления максимума
            left = [0] * n
            left[0] = dp[0]
            for c in range(1, n):
                left[c] = max(left[c - 1] - 1, dp[c])

            # Правый проход для вычисления максимума
            right = [0] * n
            right[-1] = dp[-1]
            for c in range(n - 2, -1, -1):
                right[c] = max(right[c + 1] - 1, dp[c])

            # Обновление dp для текущей строки
            for c in range(n):
                dp[c] = points[r][c] + max(left[c], right[c])

        # Максимальное значение в последней строке будет ответом
        return max(dp)


"""
Эту задачу можно решить с использованием динамического программирования. Идея заключается в следующем:

    Для каждой строки будем вычислять максимальное количество очков, которые можно получить, 
    если выбрать любую ячейку в этой строке, с учетом максимального количества очков, 
    полученного на предыдущих строках.

    Используем два вспомогательных массива left и right, 
    чтобы быстро находить максимум с учетом штрафа за разницу в столбцах.

    Будем обновлять значения в текущей строке, используя значения из предыдущей строки и рассматривая штрафы.
    
Эту задачу можно решить с использованием динамического программирования. Идея заключается в следующем:

    Для каждой строки будем вычислять максимальное количество очков, которые можно получить, если выбрать любую ячейку в этой строке, с учетом максимального количества очков, полученного на предыдущих строках.

    Используем два вспомогательных массива left и right, чтобы быстро находить максимум с учетом штрафа за разницу в столбцах.

    Будем обновлять значения в текущей строке, используя значения из предыдущей строки и рассматривая штрафы.

Подробное решение:

python

def maxPoints(points):
    m, n = len(points), len(points[0])
    
    # dp будет хранить максимальные очки на каждой строке
    dp = [0] * n
    
    for r in range(m):
        # Левый проход для вычисления максимума
        left = [0] * n
        left[0] = dp[0]
        for c in range(1, n):
            left[c] = max(left[c-1] - 1, dp[c])
        
        # Правый проход для вычисления максимума
        right = [0] * n
        right[-1] = dp[-1]
        for c in range(n-2, -1, -1):
            right[c] = max(right[c+1] - 1, dp[c])
        
        # Обновление dp для текущей строки
        for c in range(n):
            dp[c] = points[r][c] + max(left[c], right[c])
    
    # Максимальное значение в последней строке будет ответом
    return max(dp)

# Пример использования:
points = [
    [1, 2, 3],
    [1, 5, 1],
    [3, 1, 1]
]

print(maxPoints(points))  # Output: 9

Пояснение:

    Массив dp: Хранит максимальное количество очков для каждой ячейки в строке, 
    с учетом всех предыдущих строк.

    Массивы left и right:
        left[i] хранит максимальное значение из всех ячеек слева от i (включительно), 
        с учетом штрафа за переход.
        right[i] хранит максимальное значение из всех ячеек справа от i (включительно), 
        с учетом штрафа за переход.

    Обновление dp: Для каждой ячейки в строке выбираем максимум между left[c] и right[c], 
    добавляя текущее значение ячейки из points.

Таким образом, алгоритм проходит через каждую строку и столбец, 
обновляя максимальные очки с учетом предыдущих строк и штрафов, 
что позволяет эффективно решить задачу.
"""

points = [[1,2,3],[1,5,1],[3,1,1]]
sol = Solution()
res = sol.maxPoints(points)
print(res)
assert res == 9

points = [[1,5],[2,3],[4,2]]
sol = Solution()
res = sol.maxPoints(points)
print(res)
assert res == 11
