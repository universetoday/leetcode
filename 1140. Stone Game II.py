"""
Alice and Bob continue their games with piles of stones.
There are a number of piles arranged in a row,
and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones.

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles,
where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.
-------------------------------
Алиса и Боб продолжают свои игры с кучами камней.
Существует ряд куч, и в каждой куче есть положительное целое число камней piles[i].
Цель игры — собрать больше всего камней.

Алиса и Боб ходят по очереди, причем Алиса начинает первой.  Изначально M = 1.

На каждом ходе игрок может взять все камни из первых X оставшихся куч,
где 1 <= X <= 2M. Затем мы устанавливаем M = max(M, X).

Игра продолжается до тех пор, пока все камни не будут собраны.

Предполагая, что Алиса и Боб играют оптимально, верните максимальное количество камней,
 которое может собрать Алиса.
-------------------------------
MEDIUM
"""
from typing import List


class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)

        # Предварительный подсчет сумм от i до конца
        suffixSum = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suffixSum[i] = suffixSum[i + 1] + piles[i]

        # Мемоизация для хранения промежуточных результатов
        memo = {}

        def dp(i, M):
            # Если уже рассмотрели все кучи
            if i == n:
                return 0
            # Если результат уже был вычислен
            if (i, M) in memo:
                return memo[(i, M)]

            maxStones = 0
            for X in range(1, 2 * M + 1):
                if i + X > n:
                    break
                # Вычисляем сколько камней может взять текущий игрок
                maxStones = max(maxStones, suffixSum[i] - dp(i + X, max(M, X)))

            # Сохраняем результат в мемоизацию
            memo[(i, M)] = maxStones
            return maxStones

        # Алиса начинает с 0 позиции и M = 1
        return dp(0, 1)


"""
Решение задачи с использованием динамического программирования (DP), 
описанное выше, имеет временную сложность O(n3)O(n3), 
что может быть неэффективно для больших массивов piles. 
Давайте попробуем оптимизировать решение, снизив временную сложность до O(n2)O(n2).
Основная идея оптимизации:

Чтобы избежать вложенного цикла, который приводит к сложности O(n3)O(n3), 
можно использовать дополнительный массив для хранения уже подсчитанных значений 
максимального количества камней, которые Алиса может получить, начиная с позиции i. 
Это позволит избавиться от одного из вложенных циклов.
Оптимизированное решение:

    Массив suffixSum: Предварительно вычислим массив, 
    который будет хранить сумму всех камней, начиная с позиции i до конца. 
    Это позволит ускорить доступ к информации о сумме камней.

    Рекурсивное вычисление с мемоизацией: 
    Вместо тройного цикла будем использовать рекурсию с мемоизацией, 
    чтобы запоминать уже вычисленные состояния и не пересчитывать их заново.
    
Временная сложность:

    Рекурсия с мемоизацией гарантирует, 
    что каждое состояние (i, M) будет вычислено только один раз.
    Поскольку MM может изменяться в пределах от 1 до nn,
    общее количество различных состояний, которые нужно будет вычислить, составляет O(n2)O(n2).
    Внутри каждого состояния выполняется цикл с длиной до 2M2M, 
    но это уже не доминирует по сложности, так как количество состояний ограничено.

Таким образом, временная сложность этого решения составляет O(n2).
"""


piles = [2,7,9,4,4]
sol = Solution()
res = sol.stoneGameII(piles)
print(res)
assert res == 10

piles = [1,2,3,4,5,100]
sol = Solution()
res = sol.stoneGameII(piles)
print(res)
assert res == 104
