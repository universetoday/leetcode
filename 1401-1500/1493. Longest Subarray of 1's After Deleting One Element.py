"""
Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array.
Return 0 if there is no such subarray.
------------------------
Дан массив nums, содержащий только 0 и 1. Вам нужно удалить один элемент из массива.

Вам нужно вернуть размер самого длинного подмассива, содержащего только 1,
который можно получить после удаления одного элемента. Если такого подмассива не существует, верните 0.
------------------------
MEDIUM
"""
from typing import List


class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        left = 0
        zero_count = 0
        max_len = 0

        for right in range(len(nums)):
            if nums[right] == 0:
                zero_count += 1

            while zero_count > 1:
                if nums[left] == 0:
                    zero_count -= 1
                left += 1

            max_len = max(max_len, right - left)

        return max_len


"""
Для решения задачи можно использовать подход с двумя указателями (двойной указатель или sliding window).
Объяснение:

    Используем два указателя (left и right): Мы будем перемещать правый указатель (right) по массиву и 
    подсчитывать количество нулей в текущем окне. Если количество нулей больше одного, 
    сдвигаем левый указатель (left), чтобы уменьшить окно, пока в нем не останется только один ноль.

    Обновляем максимальную длину: В каждый момент времени, когда у нас есть допустимое окно 
    (содержит не более одного нуля), обновляем максимальную длину подмассива, который содержит только 1.

    Возвращаем результат: Так как мы удаляем один элемент, фактическая длина подмассива будет right - left.

Примеры:

    Для nums = [1,1,0,1]: После удаления одного 0, самый длинный подмассив 1's будет [1,1,1],
    длина которого равна 3.
    Для nums = [0,1,1,1,0,1,1,0,1]: После удаления центрального 0, 
    самый длинный подмассив 1's будет [1,1,1,1,1], длина которого равна 5.
    Для nums = [1,1,1]: Мы можем удалить любую 1, и самый длинный подмассив останется [1,1], 
    длина которого равна 2.
    Для nums = [0,0,0]: Невозможно создать подмассив из 1's, поэтому результат 0.

Этот алгоритм работает за линейное время O(n)O(n), 
где nn — длина массива, что делает его эффективным для данной задачи.
"""


nums = [1,1,0,1]
sol = Solution()
res = sol.longestSubarray(nums)
print(res)
assert res == 3

nums = [0,1,1,1,0,1,1,0,1]
sol = Solution()
res = sol.longestSubarray(nums)
print(res)
assert res == 5

nums = [1,1,1]
sol = Solution()
res = sol.longestSubarray(nums)
print(res)
assert res == 2
